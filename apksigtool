#!/usr/bin/python3
# encoding: utf-8
# SPDX-FileCopyrightText: 2022 FC Stegerman <flx@obfusk.net>
# SPDX-License-Identifier: AGPL-3.0-or-later

# --                                                            ; {{{1
#
# File        : apksigtool
# Maintainer  : FC Stegerman <flx@obfusk.net>
# Date        : 2022-10-26
#
# Copyright   : Copyright (C) 2022  FC Stegerman
# Version     : v0.1.0
# License     : AGPLv3+
#
# --                                                            ; }}}1

"""
parse/verify/clean android apk signing blocks & apks

apksigtool is a tool for parsing android APK Signing Blocks (either embedded in
an APK or extracted as a separate file, e.g. using apksigcopier) and verifying
APK signatures.  It can also clean them (i.e. remove everything that's not an
APK Signature Scheme v2/v3 Block or verity padding block), which can be useful
for reproducible builds.

WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!


CLI
===

$ apksigtool parse [--block] [--json] [--verbose] APK_OR_BLOCK
$ apksigtool verify APK
$ apksigtool clean [--block] [--check] [--keep HEXID] APK_OR_BLOCK


API
===

>> from apksigtool import ...
>> apk_signing_block = parse_apk_signing_block(data, apkfile=None, sdk=None)

>> show_parse_tree(apk_signing_block, verbose=False, apkfile=None, sdk=None, file=sys.stdout)
>> show_json(apk_signing_block, file=sys.stdout)

>> apk_signing_block.verify(apkfile, sdk=None)                  # raises on failure
>> verified, failed = apk_signing_block.verify_results(apkfile, sdk=None)
>> verify_apk(apkfile, sig_block=None, sdk=None)                # verify APK (uses the above)

>> verify_apk_signature_scheme(signers, apkfile, sdk=None)      # does the verification
>> APKSignatureSchemeBlock(...).verify(apkfile, sdk=None)       # uses the above

>> data_cleaned = clean_apk_signing_block(data, keep=())        # clean block
>> cleaned = clean_apk(apkfile, keep=(), check=False, sdk=None) # clean APK
"""

import datetime
import os
import struct
import sys

from binascii import hexlify
from dataclasses import dataclass, field
from hashlib import sha256, sha512
from typing import Any, Iterator, List, Literal, Mapping, Optional, TextIO, Tuple, Union

from apksigcopier import extract_v2_sig, zip_data, APKSigCopierError
from asn1crypto.keys import PublicKeyInfo as X509CertPubKeyInfo
from asn1crypto.x509 import Certificate as X509Cert
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives.asymmetric.ec import ECDSA
from cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15, PSS, MGF1
from cryptography.hazmat.primitives.hashes import SHA256, SHA512
from cryptography.hazmat.primitives.serialization import load_der_public_key

__version__ = "0.1.0"
NAME = "apksigtool"

# FIXME: list of block type IDs is incomplete
# https://source.android.com/docs/security/features/apksigning/v2#apk-signing-block-format
APK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a
APK_SIGNATURE_SCHEME_V3_BLOCK_ID = 0xf05368c0

# zero padding
VERITY_PADDING_BLOCK_ID = 0x42726577

# FIXME: opaque
# https://developer.android.com/studio/releases/gradle-plugin#dependency-metadata
#   "[...] data is compressed, encrypted by a Google Play signing key [...]"
# https://android.googlesource.com/platform/tools/apkzlib
#   src/main/java/com/android/tools/build/apkzlib/sign/SigningExtension.java
DEPENDENCY_INFO_BLOCK_ID = 0x504b4453

# FIXME: opaque
# https://bi-zone.medium.com/easter-egg-in-apk-files-what-is-frosting-f356aa9f4d1
GOOGLE_PLAY_FROSTING_BLOCK_ID = 0x2146444e

# FIXME: opaque
SOURCE_STAMP_V1_BLOCK_ID = 0x2b09189e
SOURCE_STAMP_V2_BLOCK_ID = 0x6dff800d

# FIXME: unused
STRIPPING_PROTECTION_ATTR_ID = 0xbeeff00d
PROOF_OF_ROTATION_STRUCT_ID = 0x3ba06f8c

# FIXME: incomplete
# https://android.googlesource.com/platform/tools/apksig
#   src/main/java/com/android/apksig/internal/apk/SignatureAlgorithm.java
SIGNATURE_ALGORITHM_IDS = {
    0x0101: "RSASSA-PSS with SHA2-256 digest, SHA2-256 MGF1, 32 bytes of salt, trailer: 0xbc, content digested using SHA2-256 in 1 MB chunks",
    0x0102: "RSASSA-PSS with SHA2-512 digest, SHA2-512 MGF1, 64 bytes of salt, trailer: 0xbc, content digested using SHA2-512 in 1 MB chunks",
    0x0103: "RSASSA-PKCS1-v1_5 with SHA2-256 digest, content digested using SHA2-256 in 1 MB chunks",   # for build systems which require deterministic signatures
    0x0104: "RSASSA-PKCS1-v1_5 with SHA2-512 digest, content digested using SHA2-512 in 1 MB chunks",   # for build systems which require deterministic signatures
    0x0201: "ECDSA with SHA2-256 digest, content digested using SHA2-256 in 1 MB chunks",
    0x0202: "ECDSA with SHA2-512 digest, content digested using SHA2-512 in 1 MB chunks",
    0x0301: "DSA with SHA2-256 digest, content digested using SHA2-256 in 1 MB chunks",
#   0x0301: "DSA with SHA2-256 digest, content digested using SHA2-256 in 1 MB chunks. Signing is done deterministically according to RFC 6979",    # noqa: E122
    0x0421: "RSASSA-PKCS1-v1_5 with SHA2-256 digest, content digested using SHA2-256 in 4 KB chunks, in the same way fsverity operates; this digest and the content length (before digestion, 8 bytes in little endian) construct the final digest",
    0x0423: "ECDSA with SHA2-256 digest, content digested using SHA2-256 in 4 KB chunks, in the same way fsverity operates; this digest and the content length (before digestion, 8 bytes in little endian) construct the final digest",
    0x0425: "DSA with SHA2-256 digest, content digested using SHA2-256 in 4 KB chunks, in the same way fsverity operates; this digest and the content length (before digestion, 8 bytes in little endian) construct the final digest",
}

CHUNKED, VERITY = 1, 2

# FIXME: incomplete
HASHERS = {
    # id     algo   hasher  halgo   pad                                              chunk_type
    0x0101: ("rsa", sha256, SHA256, lambda: PSS(mgf=MGF1(SHA256()), salt_length=32), CHUNKED),
    0x0102: ("rsa", sha512, SHA512, lambda: PSS(mgf=MGF1(SHA512()), salt_length=64), CHUNKED),
    0x0103: ("rsa", sha256, SHA256, PKCS1v15, CHUNKED),
    0x0104: ("rsa", sha512, SHA512, PKCS1v15, CHUNKED),
    0x0201: ("ec", sha256, lambda: ECDSA(SHA256()), None, CHUNKED),
    0x0202: ("ec", sha512, lambda: ECDSA(SHA512()), None, CHUNKED),
    0x0301: ("dsa", sha256, SHA256, None, CHUNKED),
    0x0421: ("rsa", sha256, SHA256, PKCS1v15, VERITY),
    0x0423: ("ec", sha256, lambda: ECDSA(SHA256()), None, VERITY),      # NB: untested
    0x0425: ("dsa", sha256, SHA256, None, VERITY),                      # NB: untested
}

assert set(SIGNATURE_ALGORITHM_IDS.keys()) == set(HASHERS.keys())

CHUNK_SIZE = 1048576
VERITY_BLOCK_SIZE = 4096

# FIXME
VERITY_SALT = b"\x00" * 8


class APKSigToolError(Exception):
    """Base class for errors."""


class VerificationError(APKSigToolError):
    """Verification failure."""


class AssertionFailed(APKSigToolError):
    """Assertion failure."""


@dataclass(frozen=True)
class APKSigToolBase:
    """Base class for dataclasses."""

    def for_json(self) -> Mapping[str, Any]:
        """Convert to JSON: dict of all attributes not starting with _, plus _type."""
        d = {k: v for k, v in self.__dict__.items() if not k.startswith("_")}
        return dict(_type=self.__class__.__name__, **d)


@dataclass(frozen=True)
class CertificateInfo(APKSigToolBase):
    """X.509 certificate info."""
    subject: str
    issuer: str
    serial_number: int
    hash_algorithm: str
    signature_algorithm: str
    not_valid_before: datetime.datetime
    not_valid_after: datetime.datetime
    fingerprint: str


@dataclass(frozen=True)
class PublicKeyInfo(APKSigToolBase):
    """Public key info."""
    algorithm: str
    bit_size: int
    fingerprint: str
    hash_algorithm: Optional[str]


@dataclass(frozen=True)
class Block(APKSigToolBase):
    """Base class for APKSigningBlock etc."""


@dataclass(frozen=True)
class Pair(APKSigToolBase):
    """ID-value pair."""
    length: int
    id: int
    value: Block


@dataclass(frozen=True)
class Digest(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signed data -> digest."""
    signature_algorithm_id: int
    digest: bytes
    algoritm_id_info: str = field(init=False)

    def __post_init__(self):
        object.__setattr__(self, "algoritm_id_info", aid_info(self.signature_algorithm_id))


@dataclass(frozen=True)
class Certificate(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signed data -> certificate."""
    raw_data: bytes
    _certificate: X509Cert = field(init=False)
    _public_key: X509CertPubKeyInfo = field(init=False)
    certificate_info: CertificateInfo = field(init=False)
    public_key_info: PublicKeyInfo = field(init=False)

    def __post_init__(self):
        object.__setattr__(self, "_certificate", X509Cert.load(self.raw_data))
        object.__setattr__(self, "_public_key", self.certificate.public_key)
        object.__setattr__(self, "certificate_info", x509_certificate_info(self.certificate))
        object.__setattr__(self, "public_key_info", public_key_info(self.public_key))

    @property
    def certificate(self) -> X509Cert:
        return self._certificate

    @property
    def public_key(self) -> X509CertPubKeyInfo:
        return self._public_key


@dataclass(frozen=True)
class AdditionalAttribute(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signed data -> additional attribute."""
    id: int
    value: bytes

    @property
    def is_stripping_protection(self) -> bool:
        return self.id == STRIPPING_PROTECTION_ATTR_ID

    @property
    def is_proof_of_rotation_struct(self) -> bool:
        return self.id == PROOF_OF_ROTATION_STRUCT_ID

    def for_json(self) -> Mapping[str, Any]:
        x = super().for_json()
        y = dict(is_stripping_protection=self.is_stripping_protection,
                 is_proof_of_rotation_struct=self.is_proof_of_rotation_struct)
        return {**x, **y}


@dataclass(frozen=True)
class Signature(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signature."""
    signature_algorithm_id: int
    signature: bytes
    algoritm_id_info: str = field(init=False)

    def __post_init__(self):
        object.__setattr__(self, "algoritm_id_info", aid_info(self.signature_algorithm_id))


@dataclass(frozen=True)
class PublicKey(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> public key."""
    raw_data: bytes
    _public_key: X509CertPubKeyInfo = field(init=False)
    public_key_info: PublicKeyInfo = field(init=False)

    def __post_init__(self):
        object.__setattr__(self, "_public_key", X509CertPubKeyInfo.load(self.raw_data))
        object.__setattr__(self, "public_key_info", public_key_info(self.public_key))

    @property
    def public_key(self) -> X509CertPubKeyInfo:
        return self._public_key


@dataclass(frozen=True)
class V2SignedData(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signed data (v2)."""
    raw_data: bytes
    digests: Tuple[Digest, ...]
    certificates: Tuple[Certificate, ...]
    additional_attributes: Tuple[AdditionalAttribute, ...]


@dataclass(frozen=True)
class V3SignedData(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer -> signed data (v3)."""
    raw_data: bytes
    digests: Tuple[Digest, ...]
    certificates: Tuple[Certificate, ...]
    min_sdk: int
    max_sdk: int
    additional_attributes: Tuple[AdditionalAttribute, ...]


@dataclass(frozen=True)
class V2Signer(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer (v2)."""
    signed_data: V2SignedData
    signatures: Tuple[Signature, ...]
    public_key: PublicKey


@dataclass(frozen=True)
class V3Signer(APKSigToolBase):
    """APK Signature Scheme v2/v3 Block -> signer (v3)."""
    signed_data: V3SignedData
    min_sdk: int
    max_sdk: int
    signatures: Tuple[Signature, ...]
    public_key: PublicKey


@dataclass(frozen=True)
class APKSigningBlock(APKSigToolBase):
    """APK Signing Block."""
    pairs: Tuple[Pair, ...]

    # FIXME
    # WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
    def verify(self, apkfile: str, sdk: Optional[int] = None) -> None:
        """
        Verify APK file using the APK Signature Scheme v2/v3 Blocks found in
        this APKSigningBlock.

        WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!

        Raises VerificationError on failure.
        """
        for pair in self.pairs:
            if isinstance(b := pair.value, APKSignatureSchemeBlock):
                b.verify(apkfile, sdk=sdk)

    # FIXME
    # WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
    def verify_results(self, apkfile: str, sdk: Optional[int] = None) \
            -> Tuple[Tuple[int, ...], Tuple[Tuple[int, Exception], ...]]:
        """
        Verify APK file using the APK Signature Scheme v2/v3 Blocks found in
        this APKSigningBlock.

        WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!

        Returns (verified, failed), where verified is a tuple of versions for
        verification successes, and failed is a tuple of (version, exception) tuples
        of verification failures.
        """
        verified, failed = [], []
        for pair in self.pairs:
            if isinstance(b := pair.value, APKSignatureSchemeBlock):
                try:
                    b.verify(apkfile, sdk=sdk)
                except VerificationError as e:
                    failed.append((b.version, e))
                else:
                    verified.append(b.version)
        return tuple(verified), tuple(failed)


@dataclass(frozen=True)
class APKSignatureSchemeBlock(Block):
    """APK Signature Scheme v2/v3 Block."""
    version: Literal[2, 3]
    signers: Tuple[Union[V2Signer, V3Signer], ...]
    verified: Optional[bool]
    verification_error: Optional[str]

    def __post_init__(self):
        assert (self.verification_error is not None) == (self.verified == False)  # noqa: E712
        if self.is_v2:
            assert all(isinstance(s, V2Signer) for s in self.signers)
        else:
            assert all(isinstance(s, V3Signer) for s in self.signers)

    @property
    def is_v2(self) -> bool:
        return self.version == 2

    @property
    def is_v3(self) -> bool:
        return self.version == 3

    # FIXME
    # WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
    def verify(self, apkfile: str, sdk: Optional[int] = None) -> None:
        """
        Verify APK Signature Scheme using verify_apk_signature_scheme().

        WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
        """
        verify_apk_signature_scheme(self.signers, apkfile=apkfile, sdk=sdk)


@dataclass(frozen=True)
class VerityPaddingBlock(Block):
    """Verity padding block (zero padding)."""


@dataclass(frozen=True)
class DependencyInfoBlock(Block):
    """Google dependency info block (opaque, encrypted)."""
    raw_data: bytes


@dataclass(frozen=True)
class GooglePlayFrostingBlock(Block):
    """Google Play frosting block (opaque)."""
    raw_data: bytes


@dataclass(frozen=True)
class SourceStampBlock(Block):
    """Google source stamp block (opaque)."""
    raw_data: bytes
    version: Literal[1, 2]


@dataclass(frozen=True)
class UnknownBlock(Block):
    """Unknown block."""
    raw_data: bytes


def _assert(b: bool, what: Optional[str] = None) -> None:
    """
    assert that is not removed with optimization.

    >>> from apksigtool import _assert
    >>> _assert(1 == 1, "all good")
    >>> _assert(1 == 2, "oops") # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    AssertionFailed: Assertion failed: oops

    """
    if not b:
        raise AssertionFailed("Assertion failed" + (f": {what}" if what else ""))


def parse_apk_signing_block(data: bytes, apkfile: Optional[str] = None,
                            sdk: Optional[int] = None) -> APKSigningBlock:
    """
    Parse APK Signing Block (a sequence of pairs).

    The apkfile parameter is passed down to parse_apk_signature_scheme_block()
    (along with the sdk parameter), which will attempt to verify the APK using
    verify_apk_signature_scheme() when it is not None.

    Returns APKSigningBlock with .pairs a tuple of Pair (with .length, .id,
    .value; each .value is e.g. an APKSignatureSchemeBlock or other block type,
    UnknownBlock if not identified).
    """
    return APKSigningBlock(tuple(_parse_apk_signing_block(data, apkfile=apkfile, sdk=sdk)))


# https://source.android.com/docs/security/features/apksigning/v2#apk-signing-block-format
def _parse_apk_signing_block(data: bytes, apkfile: Optional[str] = None,
                             sdk: Optional[int] = None) -> Iterator[Pair]:
    """Yield Pair(s) (with e.g. an APKSignatureSchemeBlock as .value)."""
    magic = data[-16:]
    sb_size1 = int.from_bytes(data[:8], "little")
    sb_size2 = int.from_bytes(data[-24:-16], "little")
    _assert(magic == b"APK Sig Block 42", "APK Sig Block magic")
    _assert(sb_size1 == sb_size2 == len(data) - 8, "APK Sig Block size")
    data = data[8:-24]
    while data:
        value: Block
        pair_len, pair_id = struct.unpack("<QL", data[:12])
        pair_val, data = data[12:8 + pair_len], data[8 + pair_len:]
        if pair_id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID:
            value = parse_apk_signature_scheme_block(2, pair_val, apkfile=apkfile, sdk=sdk)
        elif pair_id == APK_SIGNATURE_SCHEME_V3_BLOCK_ID:
            value = parse_apk_signature_scheme_block(3, pair_val, apkfile=apkfile, sdk=sdk)
        elif pair_id == VERITY_PADDING_BLOCK_ID:
            _assert(all(b == 0 for b in pair_val), "verity zero padding")
            value = VerityPaddingBlock()
        elif pair_id == DEPENDENCY_INFO_BLOCK_ID:
            value = DependencyInfoBlock(pair_val)
        elif pair_id == GOOGLE_PLAY_FROSTING_BLOCK_ID:
            value = GooglePlayFrostingBlock(pair_val)
        elif pair_id == SOURCE_STAMP_V1_BLOCK_ID:
            value = SourceStampBlock(pair_val, 1)
        elif pair_id == SOURCE_STAMP_V2_BLOCK_ID:
            value = SourceStampBlock(pair_val, 2)
        else:
            value = UnknownBlock(pair_val)
        yield Pair(pair_len, pair_id, value)


# FIXME
def clean_apk_signing_block(data: bytes, keep: Tuple[int, ...] = ()) -> bytes:
    """
    Clean APK Signing Block: remove everything that's not an APK Signature
    Scheme v2/v3 Block or verity padding block (or has a pair_id in keep).

    Returns cleaned block (bytes).
    """
    magic = data[-16:]
    sb_size1 = int.from_bytes(data[:8], "little")
    sb_size2 = int.from_bytes(data[-24:-16], "little")
    _assert(magic == b"APK Sig Block 42", "APK Sig Block magic")
    _assert(sb_size1 == sb_size2 == len(data) - 8, "APK Sig Block size")
    data = data[8:-24]
    cleaned = b""
    while data:
        pair_len, pair_id = struct.unpack("<QL", data[:12])
        pair, data = data[:8 + pair_len], data[8 + pair_len:]
        if pair_id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID:
            pass
        elif pair_id == APK_SIGNATURE_SCHEME_V3_BLOCK_ID:
            pass
        elif pair_id == VERITY_PADDING_BLOCK_ID:
            _assert(all(b == 0 for b in pair[12:]), "verity zero padding")
        elif pair_id in keep:
            pass
        else:
            continue
        cleaned += pair
    c_size = int.to_bytes(len(cleaned) + 24, 8, "little")
    return c_size + cleaned + c_size + magic


def parse_apk_signature_scheme_block(version: Literal[2, 3], data: bytes, apkfile: Optional[str] = None,
                                     sdk: Optional[int] = None) -> APKSignatureSchemeBlock:
    """
    Parse APK Signature Scheme v2/v3 Block (and attempt to verify -- setting
    .verified to True or False instead of None -- if apkfile is not None).

    Returns APKSignatureSchemeBlock (with .version, .signers, .verified,
    .verification_error).
    """
    signers = tuple(_parse_apk_signature_scheme_block(data, version == 3))
    verified, verification_error = None, None
    if apkfile is not None:
        try:
            verify_apk_signature_scheme(signers, apkfile=apkfile, sdk=sdk)
        except VerificationError as e:
            verified, verification_error = False, str(e)
        else:
            verified = True
    return APKSignatureSchemeBlock(version, signers, verified, verification_error)


def _parse_apk_signature_scheme_block(data: bytes, v3: bool) -> Iterator[Union[V2Signer, V3Signer]]:
    """Yield V2Signer/V3Signer(s) for each parse_signer()."""
    seq_len, data = int.from_bytes(data[:4], "little"), data[4:]
    _assert(seq_len == len(data), "APK Signature Scheme Block size")
    while data:
        signer, data = _len_prefixed_field(data)
        yield parse_signer(signer, v3)


def parse_signer(data: bytes, v3: bool) -> Union[V2Signer, V3Signer]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer.

    Returns V2Signer/V3Signer (with .signed_data, .signatures, .public_key;
    V3Signer also .min_sdk, .max_sdk).
    """
    result: List = []
    sigdata, data = _len_prefixed_field(data)
    result.append(parse_signed_data(sigdata, v3))
    if v3:
        minSDK, maxSDK = struct.unpack("<LL", data[:8])
        data = data[8:]
        result.append(minSDK)
        result.append(maxSDK)
    sigs, data = _len_prefixed_field(data)
    result.append(parse_signatures(sigs))
    pubkey, data = _len_prefixed_field(data)
    result.append(PublicKey(pubkey))
    _assert(all(b == 0 for b in data), "signer zero padding")
    return (V3Signer if v3 else V2Signer)(*result)


def parse_signed_data(data: bytes, v3: bool) -> Union[V2SignedData, V3SignedData]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer -> signed data.

    Returns V2SignedData/V3SignedData (with .raw_data, .digests, .certificates,
    .additional_attributes; V3SignedData also .min_sdk, .max_sdk).
    """
    result: List = [data]
    digests, data = _len_prefixed_field(data)
    result.append(parse_digests(digests))
    certs, data = _len_prefixed_field(data)
    result.append(parse_certificates(certs))
    if v3:
        minSDK, maxSDK = struct.unpack("<LL", data[:8])
        data = data[8:]
        result.append(minSDK)
        result.append(maxSDK)
    attrs, data = _len_prefixed_field(data)
    result.append(parse_additional_attributes(attrs))
    _assert(all(b == 0 for b in data), "signed data zero padding")
    return (V3SignedData if v3 else V2SignedData)(*result)


def parse_digests(data: bytes) -> Tuple[Digest, ...]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer -> signed data -> digests.

    Returns tuple of Digest (with .signature_algorithm_id, .digest).
    """
    return tuple(_parse_digests(data))


def _parse_digests(data: bytes) -> Iterator[Digest]:
    """Yield Digest(s)."""
    while data:
        digest, data = _len_prefixed_field(data)
        sig_algo_id = int.from_bytes(digest[:4], "little")
        _assert(int.from_bytes(digest[4:8], "little") == len(digest) - 8, "digest size")
        yield Digest(sig_algo_id, digest[8:])


def parse_certificates(data: bytes) -> Tuple[Certificate, ...]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer -> signed data ->
    certificates.

    Returns tuple of Certificate (with .raw_data).
    """
    return tuple(_parse_certificates(data))


def _parse_certificates(data: bytes) -> Iterator[Certificate]:
    """Yield Certificate(s)."""
    while data:
        cert, data = _len_prefixed_field(data)
        yield Certificate(cert)


def parse_additional_attributes(data: bytes) -> Tuple[AdditionalAttribute, ...]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer -> signed data ->
    additional attributes.

    Returns tuple of AdditionalAttribute (with .id, .value).
    """
    return tuple(_parse_additional_attributes(data))


def _parse_additional_attributes(data: bytes) -> Iterator[AdditionalAttribute]:
    """Yield AdditionalAttribute(s)."""
    while data:
        attr, data = _len_prefixed_field(data)
        attr_id = int.from_bytes(attr[:4], "little")
        yield AdditionalAttribute(attr_id, attr[4:])


def parse_signatures(data: bytes) -> Tuple[Signature, ...]:
    """
    Parse APK Signature Scheme v2/v3 Block -> signer -> signatures.

    Returns tuple of Signature (with .signature_algorithm_id, .signature).
    """
    return tuple(_parse_signatures(data))


def _parse_signatures(data: bytes) -> Iterator[Signature]:
    """Yield Signature(s)."""
    while data:
        sig, data = _len_prefixed_field(data)
        sig_algo_id = int.from_bytes(sig[:4], "little")
        _assert(int.from_bytes(sig[4:8], "little") == len(sig) - 8, "signature size")
        yield Signature(sig_algo_id, sig[8:])


def _len_prefixed_field(data: bytes) -> Tuple[bytes, bytes]:
    """
    Parse length-prefixed field (length is little-endian, uint32) at beginning
    of data.

    Returns (field data, remaining data).
    """
    _assert(len(data) >= 4, "prefixed field must be at least 4 bytes")
    field_len = int.from_bytes(data[:4], "little")
    _assert(len(data) >= 4 + field_len, "prefixed field size")
    return data[4:4 + field_len], data[4 + field_len:]


# FIXME: check & audit!
# WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
# https://source.android.com/docs/security/features/apksigning/v2#v2-verification
# https://source.android.com/docs/security/features/apksigning/v3#v3-verification
def verify_apk_signature_scheme(signers: Tuple[Union[V2Signer, V3Signer], ...],
                                apkfile: str, sdk: Optional[int] = None) -> None:
    """
    Verify APK Signature Scheme v2/v3.

    WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!

    NB: currently verifies all signatures, not just the one with the strongest
    supported signature algorithm ID.

    Raises VerificationError on failure.
    """
    sb_offset, _ = _extract_v2_sig(apkfile)
    verified = 0
    if not signers:
        raise VerificationError("No signers")
    if not any(all(isinstance(s, c) for s in signers) for c in (V2Signer, V3Signer)):
        raise VerificationError("Mixed v2 and v3 signers")
    for signer in signers:
        if isinstance(signer, V3Signer):
            if signer.min_sdk != signer.signed_data.min_sdk:
                raise VerificationError("Min SDK of signer and signed data are not identical")
            if signer.max_sdk != signer.signed_data.max_sdk:
                raise VerificationError("Max SDK of signer and signed data are not identical")
            if sdk is not None and not (signer.min_sdk <= sdk <= signer.max_sdk):
                continue
        if not signer.signatures:
            raise VerificationError("No signatures")
        if not signer.signed_data.certificates:
            raise VerificationError("No certificates")
        if not signer.signed_data.digests:
            raise VerificationError("No digests")
        pk = signer.public_key
        c0 = signer.signed_data.certificates[0]
        da = sorted(d.signature_algorithm_id for d in signer.signed_data.digests)
        sa = sorted(s.signature_algorithm_id for s in signer.signatures)
        pk_algo = pk.public_key.algorithm
        for sig in signer.signatures:
            if sig.signature_algorithm_id not in HASHERS:
                raise VerificationError(f"Unknown signature algorithm ID: {hex(sig.signature_algorithm_id)}")
            algo, _, halgo, pad, _ = HASHERS[sig.signature_algorithm_id]
            if pk_algo != algo:
                raise VerificationError(f"Public key algorithm mismatch: expected {algo}, got {pk_algo}")
            verify_signature(pk.raw_data, sig.signature, signer.signed_data.raw_data, halgo, pad)
        if c0.public_key.dump() != pk.raw_data:
            raise VerificationError("Public key does not match first certificate")
        if da != sa:
            raise VerificationError("Signature algorithm IDs of digests and signatures are not identical")
        for dig in signer.signed_data.digests:
            if dig.signature_algorithm_id not in HASHERS:
                raise VerificationError(f"Unknown signature algorithm ID: {hex(dig.signature_algorithm_id)}")
            _, hasher, _, _, chunk_type = HASHERS[dig.signature_algorithm_id]
            digest = _apk_digest(apkfile, sb_offset, hasher, chunk_type)
            if digest != dig.digest:
                raise VerificationError(f"Digest mismatch: expected {hexlify(dig.digest).decode()}, got {hexlify(digest).decode()}")
        verified += 1
    if not verified:
        raise VerificationError("No compatible signers")


def _apk_digest(apkfile: str, sb_offset: int, hasher, chunk_type: int) -> bytes:
    """Calculate APK digest (either chunked or verity)."""
    if chunk_type == CHUNKED:
        return apk_digest_chunked(apkfile, sb_offset, hasher)
    elif chunk_type == VERITY:
        return apk_digest_verity(apkfile, sb_offset, hasher)
    else:
        raise ValueError(f"Unknown chunk type: {chunk_type}")


def apk_digest_chunked(apkfile: str, sb_offset: int, hasher) -> bytes:
    """Calculate chunked digest for APK."""
    def f(size):
        while size > 0:
            data = fh.read(min(size, CHUNK_SIZE))
            if not data:
                break
            size -= len(data)
            digests.append(_chunk_digest(data, hasher))
    digests: List[bytes] = []
    cd_offset, eocd_offset, _ = zip_data(apkfile)
    with open(apkfile, "rb") as fh:
        f(sb_offset)
        fh.seek(cd_offset)
        f(eocd_offset - cd_offset)
        fh.seek(eocd_offset)
        data = fh.read()
        data = data[:16] + int.to_bytes(sb_offset, 4, "little") + data[20:]
        digests.extend(_chunk_digest(c, hasher) for c in _chunks(data, CHUNK_SIZE))
    return _top_level_chunked_digest(digests, hasher)


def apk_digest_verity(apkfile: str, sb_offset: int, hasher) -> bytes:
    """Calculate verity digest for APK."""
    _assert(sb_offset % VERITY_BLOCK_SIZE == 0,
            "APK Sig Block offset must be a multiple of verity block size")
    digests = []
    cd_offset, eocd_offset, cd_and_eocd = zip_data(apkfile)
    with open(apkfile, "rb") as fh:
        size = sb_offset
        while size > 0:
            data = fh.read(min(size, VERITY_BLOCK_SIZE))
            if not data:
                break
            size -= len(data)
            digests.append(_verity_block_digest(data, hasher))
        fh.seek(0, os.SEEK_END)
        total_size = fh.tell() - (cd_offset - sb_offset)
    off = eocd_offset - cd_offset
    sbo = int.to_bytes(sb_offset, 4, "little")
    data = _verity_pad(cd_and_eocd[:off + 16] + sbo + cd_and_eocd[off + 20:])
    digests.extend(_verity_block_digest(c, hasher) for c in _chunks(data, VERITY_BLOCK_SIZE))
    return _top_level_verity_digest(digests, total_size, hasher)


def _chunk_digest(chunk: bytes, hasher) -> bytes:
    data = b"\xa5" + int.to_bytes(len(chunk), 4, "little") + chunk
    return hasher(data).digest()


def _top_level_chunked_digest(digests: List[bytes], hasher) -> bytes:
    data = b"\x5a" + int.to_bytes(len(digests), 4, "little") + b"".join(digests)
    return hasher(data).digest()


def _verity_block_digest(block: bytes, hasher) -> bytes:
    _assert(len(block) == VERITY_BLOCK_SIZE, "verity block size")
    return hasher(VERITY_SALT + block).digest()


def _top_level_verity_digest(digests: List[bytes], total_size: int, hasher) -> bytes:
    data = _verity_pad(b"".join(digests))
    while len(data) > VERITY_BLOCK_SIZE:
        data = _verity_pad(b"".join(_verity_block_digest(c, hasher)
                                    for c in _chunks(data, VERITY_BLOCK_SIZE)))
    return hasher(VERITY_SALT + data).digest() + int.to_bytes(total_size, 8, "little")


def _verity_pad(data: bytes) -> bytes:
    if len(data) % VERITY_BLOCK_SIZE != 0:
        data += b"\x00" * (VERITY_BLOCK_SIZE - (len(data) % VERITY_BLOCK_SIZE))
    return data


def _chunks(data: bytes, blocksize: int) -> Iterator[bytes]:
    """Yield chunks of blocksize from data."""
    while data:
        chunk, data = data[:blocksize], data[blocksize:]
        yield chunk


# FIXME: type checking?!
# WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
def verify_signature(key: bytes, sig: bytes, msg: bytes, halgo, pad) -> None:
    """
    Verify signature (sig) from key on message (msg) using appropriate hashing
    algorithm and padding.

    WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!

    Raises VerificationError (as a result of InvalidSignature) on failure.
    """
    k = load_der_public_key(key)
    try:
        if pad is None:
            k.verify(sig, msg, halgo())                 # type: ignore
        else:
            k.verify(sig, msg, pad(), halgo())          # type: ignore
    except InvalidSignature:
        raise VerificationError("Invalid signature")    # pylint: disable=W0707


def x509_certificate_info(cert: X509Cert) -> CertificateInfo:
    """X.509 certificate info."""
    return CertificateInfo(
        subject=cert.subject.human_friendly,
        issuer=cert.issuer.human_friendly,
        serial_number=cert.serial_number,
        hash_algorithm=cert.hash_algo.upper(),
        signature_algorithm=cert.signature_algo.upper(),
        not_valid_before=cert.not_valid_before,
        not_valid_after=cert.not_valid_after,
        fingerprint=cert.sha256_fingerprint.replace(" ", "").lower())


def public_key_info(key: X509CertPubKeyInfo) -> PublicKeyInfo:
    """Public key info."""
    try:
        algo = key.hash_algo.upper()
    except ValueError:
        algo = None
    return PublicKeyInfo(
        algorithm=key.algorithm.upper(),
        bit_size=key.bit_size,
        fingerprint=sha256(key.dump()).hexdigest(),
        hash_algorithm=algo)


def aid_info(aid: int) -> str:
    """Signature algorithm ID info."""
    return SIGNATURE_ALGORITHM_IDS.get(aid, "UNKNOWN").split(";")[0]


def show_parse_tree(apk_signing_block: APKSigningBlock, verbose: bool = False,
                    apkfile: Optional[str] = None, sdk: Optional[int] = None,
                    file: TextIO = sys.stdout) -> None:
    """Print parse tree (w/ indent etc.) to file (stdout)."""
    def p(*a):
        print(*a, file=file)
    for pair in apk_signing_block.pairs:
        b = pair.value
        if verbose:
            p("PAIR LENGTH:", pair.length)
        p("PAIR ID:", hex(pair.id))
        if isinstance(b, APKSignatureSchemeBlock):
            show_apk_signature_scheme_block(b, verbose=verbose, apkfile=apkfile,
                                            sdk=sdk, file=file)
        elif isinstance(b, VerityPaddingBlock):
            p("  VERITY PADDING BLOCK")
        elif isinstance(b, DependencyInfoBlock):
            p("  DEPENDENCY INFO BLOCK")
        elif isinstance(b, GooglePlayFrostingBlock):
            p("  GOOGLE PLAY FROSTING BLOCK")
        elif isinstance(b, SourceStampBlock):
            p(f"  SOURCE STAMP v{b.version} BLOCK")
        else:
            p("  UNKNOWN BLOCK")
        if verbose and hasattr(b, "raw_data"):
            _show_hex(b.raw_data, 2, file=file)     # type: ignore


def show_apk_signature_scheme_block(block: APKSignatureSchemeBlock, verbose: bool,
                                    apkfile: Optional[str] = None, sdk: Optional[int] = None,
                                    file: TextIO = sys.stdout) -> None:
    """Print APKSignatureSchemeBlock parse tree to file (stdout)."""
    def p(*a):
        print(*a, file=file)
    p(f"  APK SIGNATURE SCHEME v{block.version} BLOCK")
    for i, signer in enumerate(block.signers):
        p("  SIGNER", i)
        p("    SIGNED DATA")
        for j, digest in enumerate(signer.signed_data.digests):
            p("      DIGEST", j)
            _show_aid(digest, 8, verbose=verbose, file=file)
            _show_hex(digest.digest, 8, file=file)
        for j, cert in enumerate(signer.signed_data.certificates):
            p("      CERTIFICATE", j)
            cert_info, pk_info = cert.certificate_info, cert.public_key_info
            show_x509_certificate_info(cert_info, pk_info, 8, verbose=verbose, file=file)
        if block.is_v3:
            assert isinstance(signer, V3Signer)
            p("      MIN SDK:", signer.signed_data.min_sdk)
            p("      MAX SDK:", signer.signed_data.max_sdk)
        for j, attr in enumerate(signer.signed_data.additional_attributes):
            p("      ADDITIONAL ATTRIBUTE", j)
            p("        ADDITIONAL ATTRIBUTE ID:", hex(attr.id))
            if attr.is_stripping_protection:
                p("        STRIPPING PROTECTION ATTR")
            elif attr.is_proof_of_rotation_struct:
                p("        PROOF OF ROTATION STRUCT")
            _show_hex(attr.value, 8, file=file)
        if block.is_v3:
            assert isinstance(signer, V3Signer)
            p("    MIN SDK:", signer.min_sdk)
            p("    MAX SDK:", signer.max_sdk)
        for j, sig in enumerate(signer.signatures):
            p("    SIGNATURE", j)
            _show_aid(sig, 6, verbose=verbose, file=file)
            _show_hex(sig.signature, 6, file=file)
        p("    PUBLIC KEY")
        show_public_key_info(signer.public_key.public_key_info, 6, file=file)
    if apkfile is not None:
        try:
            block.verify(apkfile, sdk=sdk)
        except VerificationError as e:
            p(f"  NOT VERIFIED ({e})")
        else:
            p("  VERIFIED")
    else:
        p("  NOT VERIFIED (No APK file)")


# FIXME: show more? s/Common Name:/CN=/ etc?
def show_x509_certificate_info(info: CertificateInfo, pk_info: PublicKeyInfo,
                               indent: int, verbose: bool, file: TextIO = sys.stdout) -> None:
    """Print X.509 certificate information to file (stdout)."""
    def p(*a):
        print(*a, file=file)
    p(" " * indent + "X.509 SUBJECT:", info.subject)
    if verbose:
        p(" " * indent + "X.509 ISSUER:", info.issuer)
        p(" " * indent + "X.509 SERIAL NUMBER:", hex(info.serial_number))
        p(" " * indent + "X.509 HASH ALGORITHM:", info.hash_algorithm)
        p(" " * indent + "X.509 SIGNATURE ALGORITHM:", info.signature_algorithm)
        p(" " * indent + "X.509 NOT VALID BEFORE:", info.not_valid_before)
        p(" " * indent + "X.509 NOT VALID AFTER:", info.not_valid_after)
    p(" " * indent + "X.509 SHA256 FINGERPRINT (HEX):", info.fingerprint)
    show_public_key_info(pk_info, indent, file=file)


def show_public_key_info(info: PublicKeyInfo, indent: int, file: TextIO = sys.stdout) -> None:
    """Print public key information to file (stdout)."""
    def p(*a):
        print(*a, file=file)
    p(" " * indent + "PUBLIC KEY ALGORITHM:", info.algorithm)
    p(" " * indent + "PUBLIC KEY BIT SIZE:", info.bit_size)
    p(" " * indent + "PUBLIC KEY SHA256 FINGERPRINT (HEX):", info.fingerprint)
    if info.hash_algorithm is not None:
        p(" " * indent + "PUBLIC KEY HASH ALGORITHM:", info.hash_algorithm)


def _show_hex(data: bytes, indent: int, file: TextIO = sys.stdout) -> None:
    """Print hex value (w/ indent etc.) to file (stdout)."""
    print(" " * indent + "VALUE (HEX):", hexlify(data).decode(), file=file)


def _show_aid(x: Union[Digest, Signature], indent: int, verbose: bool, file: TextIO = sys.stdout) -> None:
    """Print signature algorithm ID (w/ indent etc.) to file (stdout)."""
    aid, aid_s = x.signature_algorithm_id, x.algoritm_id_info
    if not verbose:
        aid_s = aid_s.split(",")[0]
    print(" " * indent + f"SIGNATURE ALGORITHM ID: {hex(aid)} ({aid_s})", file=file)


def show_json(apk_signing_block: APKSigningBlock, file: TextIO = sys.stdout) -> None:
    """Print parse tree as JSON to file (stdout)."""
    import simplejson
    simplejson.dump(apk_signing_block, file, indent=2, sort_keys=True,
                    encoding=None, default=json_dump_default, for_json=True)
    print(file=file)


def json_dump_default(obj):
    """
    Returns serializable versions of bytes (hex str) and datetime.datetime (str)
    for simplejson.dump().

    >>> import io, simplejson
    >>> from apksigtool import json_dump_default
    >>> out = io.StringIO()
    >>> simplejson.dump(dict(foo=b"bar"), out, encoding=None, default=json_dump_default)
    >>> print(out.getvalue())
    {"foo": "626172"}

    """
    if isinstance(obj, bytes):
        return hexlify(obj).decode()
    if isinstance(obj, datetime.datetime):
        return str(obj)
    raise TypeError(repr(obj) + " is not JSON serializable")


def _extract_v2_sig(apkfile: str) -> Tuple[int, bytes]:
    extracted_v2_sig = extract_v2_sig(apkfile)
    assert extracted_v2_sig is not None
    return extracted_v2_sig


# FIXME
# WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
def verify_apk(apkfile: str, sig_block: Optional[bytes] = None, sdk: Optional[int] = None) \
        -> Tuple[Tuple[int, ...], Tuple[Tuple[int, Exception], ...]]:
    """
    Verify APK file using the APK Signature Scheme v2/v3 Blocks found parsing
    the APK Signing Block.

    WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!

    If sig_block is None, it will be extracted from the APK using
    extract_v2_sig().

    Returns (verified, failed), where verified is a tuple of versions for
    verification successes, and failed is a tuple of (version, exception) tuples
    of verification failures.
    """
    if sig_block is None:
        _, sig_block = _extract_v2_sig(apkfile)
    return parse_apk_signing_block(sig_block).verify_results(apkfile, sdk=sdk)


# NB: modifies in-place!
def clean_apk(apkfile: str, keep: Tuple[int, ...] = (), check: bool = False,
              sdk: Optional[int] = None) -> bool:
    """
    Clean APK file: remove everything that's not an APK Signature Scheme v2/v3
    Block or verity padding block (or has a pair_id in keep) from its APK
    Signing Block.

    NB: modifies the file in-place!.

    Does not modify the APK file when the cleaned block is equal to the
    original.

    Raises VerificationError when check is True and verify_apk() has failures or
    no successes.

    Returns True when the APK was modified, False otherwise.
    """
    sb_offset, sig_block = _extract_v2_sig(apkfile)
    if check:
        verified, failed = verify_apk(apkfile, sig_block, sdk=sdk)
        if failed or not verified:
            raise VerificationError("Verification failed")
    sig_block_cleaned = clean_apk_signing_block(sig_block, keep=keep)
    if sig_block == sig_block_cleaned:
        return False
    data_out = zip_data(apkfile)
    offset = len(sig_block_cleaned) - len(sig_block)
    with open(apkfile, "r+b") as fh:
        fh.seek(sb_offset)
        fh.write(sig_block_cleaned)
        fh.write(data_out.cd_and_eocd)
        fh.truncate()
        fh.seek(data_out.eocd_offset + offset + 16)
        fh.write(int.to_bytes(data_out.cd_offset + offset, 4, "little"))
    return True


def main():
    """CLI; requires click."""

    import click

    # FIXME
    @click.group(help="""
        apksigtool - parse/verify/clean android apk signing blocks & apks
    """)
    @click.version_option(__version__)
    def cli():
        pass

    # FIXME
    @cli.command(help="""
        Parse APK Signing Block (from APK or extracted block) and output a parse
        tree (indented with spaces) or JSON.
    """)
    @click.option("--block", is_flag=True,
                  help="APK_OR_BLOCK is an extracted block, not an APK.")
    @click.option("--json", is_flag=True, help="JSON output.")
    @click.option("--sdk-version", type=click.INT,
                  help="For v3 signers specifying min/max SDK.")
    @click.option("-v", "--verbose", is_flag=True, help="Be verbose (no-op w/ --json).")
    @click.argument("apk_or_block", type=click.Path(exists=True, dir_okay=False))
    def parse(apk_or_block, block, json, sdk_version, verbose):
        if block:
            apkfile = None
            with open(apk_or_block, "rb") as fh:
                sig_block = fh.read()
        else:
            apkfile = apk_or_block
            _, sig_block = _extract_v2_sig(apkfile)
        if json:
            show_json(parse_apk_signing_block(sig_block, apkfile=apkfile, sdk=sdk_version))
        else:
            show_parse_tree(parse_apk_signing_block(sig_block), verbose=verbose,
                            apkfile=apkfile, sdk=sdk_version)

    # FIXME
    @cli.command(help="""
        Verify APK using the APK Signature Scheme v2/v3 Blocks in its APK
        Signing Block.

        WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!
    """)
    @click.option("--sdk-version", type=click.INT,
                  help="For v3 signers specifying min/max SDK.")
    @click.argument("apk", type=click.Path(exists=True, dir_okay=False))
    def verify(apk, sdk_version):
        print("WARNING: THIS IS A PROTOTYPE; DO NOT USE IN PRODUCTION!", file=sys.stderr)
        verified, failed = verify_apk(apk, sdk=sdk_version)
        for version in verified:
            print(f"v{version} verified")
        for version, e in failed:
            print(f"v{version} not verified ({e})")
        if failed or not verified:
            sys.exit(1)

    # FIXME
    @cli.command(help="""
        Clean APK (or extracted block): remove everything that's not an APK
        Signature Scheme v2/v3 Block or verity padding block (or has a pair_id
        in keep) from its APK Signing Block.

        NB: modifies in-place!
    """)
    @click.option("--block", is_flag=True,
                  help="APK_OR_BLOCK is an extracted block, not an APK.")
    @click.option("--check", is_flag=True,
                  help="Raise error when parsing or verification (no --block) fails.")
    @click.option("--keep", multiple=True, default=(), metavar="HEXID",
                  help="Do not remove pairs with the specified hex ID(s); use multiple "
                       "times or separate IDs with commas to specify multiple IDs.")
    @click.option("--sdk-version", type=click.INT,
                  help="For v3 signers specifying min/max SDK.")
    @click.argument("apk_or_block", type=click.Path(exists=True, dir_okay=False))
    @click.pass_context
    def clean(ctx, apk_or_block, block, check, keep, sdk_version):
        try:
            keep = tuple(int(x, 16) for p in keep for x in p.split(","))
        except ValueError as e:
            p, = [x for x in clean.params if x.name == "keep"]
            raise click.exceptions.BadParameter(e.args[0], ctx, p)
        if block:
            with open(apk_or_block, "rb") as fh:
                sig_block = fh.read()
            if check:
                parse_apk_signing_block(sig_block)  # try parsing, ignore result
            sig_block_cleaned = clean_apk_signing_block(sig_block, keep=keep)
            if cleaned := (sig_block != sig_block_cleaned):
                with open(apk_or_block, "wb") as fh:
                    fh.write(sig_block_cleaned)
        else:
            cleaned = clean_apk(apk_or_block, keep=keep, check=check, sdk=sdk_version)
        if cleaned:
            print("cleaned")
        else:
            print("nothing to clean")

    # FIXME
    # @cli.command(help="""
    #     ...
    # """)
    # @click.argument("apk", type=click.Path(exists=True, dir_okay=False))
    # def sign(apk):
    #     ...

    try:
        cli(prog_name=NAME)
    except (APKSigToolError, APKSigCopierError) as e:
        print(f"Error: {e}.", file=sys.stderr)
        sys.exit(2)


if __name__ == "__main__":
    main()

# vim: set tw=80 sw=4 sts=4 et fdm=marker :
